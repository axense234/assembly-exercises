     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit, fopen, fclose, fread, fwrite      
     8                                  import exit msvcrt.dll
     9                                  import fopen msvcrt.dll
    10                                  import fclose msvcrt.dll
    11                                  import fread msvcrt.dll
    12                                  import fwrite msvcrt.dll
    13                                  
    14                                  ; Problem statement:
    15                                  ; Mutate a string by inserting uppercase letters after each lowercase letter and vice versa. The inserted letters
    16                                  ; must be of the same type as the original one.
    17                                  ; ex: "aBcD" -> "aABbcCDd"
    18                                  
    19                                  ; our data is declared here (the variables needed by our program)
    20                                  segment data use32 class=data
    21 00000000 756C5F737472696E67-         fin_name db "ul_strings_in.txt", 0
    21 00000009 735F696E2E74787400 
    22 00000012 756C5F737472696E67-         fout_name db "ul_strings_out.txt", 0
    22 0000001B 735F6F75742E747874-
    22 00000024 00                 
    23                                      
    24 00000025 7200                        fin_mode db "r", 0
    25 00000027 7700                        fout_mode db "w", 0
    26                                      
    27 00000029 00000000                    fin dd 0
    28 0000002D 00000000                    fout dd 0
    29                                      
    30                                      LEN equ 255
    31 00000031 <res 00000100>              buffer_in resb LEN + 1
    32 00000131 <res 000001FF>              buffer_out resb (LEN * 2) + 1
    33                                      
    34 00000330 00000000                    nb_of_bytes dd 0
    35                                      
    36                                  
    37                                  ; our code starts here
    38                                  segment code use32 class=code
    39                                      start:
    40                                          ; open fin and fout
    41 00000000 68[25000000]                    push fin_mode
    42 00000005 68[00000000]                    push fin_name
    43 0000000A FF15[00000000]                  call [fopen]
    44 00000010 83C408                          add esp, 2 * 4
    45 00000013 85C0                            test eax, eax
    46 00000015 7469                            jz read_end
    47 00000017 A3[29000000]                    mov [fin], eax
    48                                          
    49 0000001C 68[27000000]                    push fout_mode
    50 00000021 68[12000000]                    push fout_name
    51 00000026 FF15[00000000]                  call [fopen]
    52 0000002C 83C408                          add esp, 2 * 4
    53 0000002F 85C0                            test eax, eax
    54 00000031 744D                            jz read_end
    55 00000033 A3[2D000000]                    mov [fout], eax
    56                                          
    57                                          ; read from the fin and write to fout
    58                                          read_start:
    59                                              ; read
    60 00000038 FF35[29000000]                      push dword [fin]
    61 0000003E 68FF000000                          push LEN
    62 00000043 6A01                                push 1
    63 00000045 68[31000000]                        push buffer_in
    64 0000004A FF15[00000000]                      call [fread]
    65 00000050 83C410                              add esp, 4 * 4
    66                                              
    67                                              ; exit reading if no more data to read
    68 00000053 83F800                              cmp eax, 0
    69 00000056 7E28                                jle read_end
    70                                              
    71                                              ; store the length of the read buffer
    72 00000058 A3[30030000]                        mov [nb_of_bytes], eax
    73                                              
    74                                              ; mutate the string
    75 0000005D E844000000                          call mutate_string
    76                                              
    77                                              ; write to fout the mutated string
    78 00000062 FF35[2D000000]                      push dword [fout]
    79 00000068 FF35[30030000]                      push dword [nb_of_bytes]
    80 0000006E 6A01                                push 1
    81 00000070 68[31010000]                        push buffer_out
    82 00000075 FF15[00000000]                      call [fwrite]
    83 0000007B 83C410                              add esp, 4 * 4
    84                                              
    85 0000007E EBB8                                jmp read_start
    86                                          read_end:
    87                                          
    88 00000080 FF35[29000000]                  push dword [fin]
    89 00000086 FF15[00000000]                  call [fclose]
    90 0000008C 83C404                          add esp, 1 * 4
    91                                          
    92 0000008F FF35[2D000000]                  push dword [fout]
    93 00000095 FF15[00000000]                  call [fclose]
    94 0000009B 83C404                          add esp, 1 * 4
    95                                          
    96                                          ; exit(0)
    97 0000009E 6A00                            push    dword 0
    98 000000A0 FF15[00000000]                  call    [exit]
    99                                      
   100                                      
   101                                      mutate_string:
   102                                      
   103 000000A6 BE[31000000]                    mov esi, buffer_in
   104 000000AB BF[31010000]                    mov edi, buffer_out
   105 000000B0 8B0D[30030000]                  mov ecx, [nb_of_bytes]
   106 000000B6 BA00000000                      mov edx, 0 ; length of newly mutated string
   107                                          
   108                                          mutate_start:
   109 000000BB AC                                  lodsb ; load byte from [esi] into AL, ++ESI
   110 000000BC AA                                  stosb ; store AL into [edi], ++EDI
   111 000000BD 42                                  inc edx ; ++edx
   112                                              
   113                                              ; check if char is lowercase
   114 000000BE 3C61                                cmp al, 'a'
   115 000000C0 720A                                jb check_uppercase
   116                                              
   117 000000C2 3C7A                                cmp al, 'z'
   118 000000C4 7706                                ja check_uppercase
   119                                              
   120                                              ; letter is lowercase
   121                                              ; we convert it to uppercase
   122 000000C6 2C20                                sub al, 32
   123 000000C8 AA                                  stosb ; store AL into [edi], ++EDI
   124 000000C9 42                                  inc edx ; ++edx
   125 000000CA EB0E                                jmp next_char
   126                                              
   127                                              
   128                                              check_uppercase:
   129 000000CC 3C41                                    cmp al, 'A'
   130 000000CE 720A                                    jb next_char
   131                                                  
   132 000000D0 3C5A                                    cmp al, 'Z'
   133 000000D2 7706                                    ja next_char
   134                                                  
   135                                                  ; letter is uppercase
   136                                                  ; we convert it to lowercase
   137 000000D4 0420                                    add al, 32
   138 000000D6 AA                                      stosb ; store AL into [edi], ++edi
   139 000000D7 42                                      inc edx ; ++edx
   140 000000D8 EB00                                    jmp next_char
   141                                               
   142                                              
   143                                          next_char:
   144 000000DA E2DF                                loop mutate_start
   145                                          
   146 000000DC 8915[30030000]                  mov [nb_of_bytes], edx ; update length of string
   147                                          
   148 000000E2 C3                              ret
   149                                              
   150                                          
   151                                      
